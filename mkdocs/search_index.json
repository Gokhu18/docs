{
    "docs": [
        {
            "location": "/", 
            "text": "OpenBazaar Developer Reference\n\n\n\nWhat is OpenBazaar?\n\n\nOpenBazaar is a new way to buy and sell goods and services online. By running a program on your computer, you can connect directly to other users in the OpenBazaar network and trade with them. The network isn't controlled by a company or organization. OpenBazaar is a decentralised peer-to-peer network, which means there are no listing fees and the marketplace is censorship-resistant.\n\n\nGoods and services are bought and sold on OpenBazaar using Bitcoin, a digital cryptocurrency that is decentralised and censorship-resistant. Transaction fees on the Bitcoin network are very cheap.\n\n\nBitcoin and OpenBazaar together make online commerce cheaper and more free than ever before.\n\n\nRight now, online commerce means using centralized services. eBay, Amazon, Alibaba and others have restrictive policies and charge fees for listing and selling goods. They only accept forms of payment that cost both buyers and sellers money, such as credit cards or PayPal/Alipay. They require personal information, which can lead to it being stolen or even sold to others for advertising or worse. Buyers and sellers aren\u2019t always free to exchange goods and services with each other, as companies and governments censor entire categories of trade.\n\n\nOpenBazaar is a different approach to online commerce. It puts the power back in the users\u2019 hands. Instead of buyers and sellers going through a centralized service, OpenBazaar connects them directly. Because there is no one in the middle of the transactions, there are no fees, no one can censor transactions, and you only reveal the personal information that you choose.\n\n\nThis project is open source, which means the code is publicly available for people to review or audit, as well as contribute code to make it better.\n\n\nAbout this documentation\n\n\nThis developer reference aims to provide you with a technical understanding of how OpenBazaar works as well as document, in detail, the OpenBazaar protocol specification. The reference implementation of the OpenBazaar protocol is \nopenbazaar-go\n, server daemon written in the \nGo\n programming language. \n\n\nWhile the openbazaar-go API is not part of the formal protocol spec, it is also documented here along with a number of examples to help you start building apps on top of the protocol. \n\n\nRunning OpenBazaar\n\n\nThe reference implementation is technically two separate applications \u2015 a \ndaemon\n which silently runs in the background and a user-interface which communicates with the running daemon. The \ndaemon\n is the application which does all of the heavy-lifting. Among other things, it maintains peer to peer network connections, serves a user's product listings to other peers when requested, processes incoming orders and bitcoin transactions, and fetches content from other peers when you ask it to. \n\n\nThe user interface, or client, runs in a packaged Chromium browser (see \nelectron\n) and communicates with the daemon via an API.\n\n\nA typical install of OpenBazaar bundles both the openbazaar-go daemon and user interface into a single application and launches both at the same time. From the user's perspective, it appears to be a single application.\n\n\nThe reason for this modular design is to make it easy for power users to run the openbazaar-go daemon on a separate device, perhaps a server, and keep it running 24/7 if they desire. In this configuration a user only needs the client installed on their computer and can connect it to the daemon via the internet. \n\n\nIf you have not already done so, we suggest you download OpenBazaar and check it out. You can download the full (bundled) application from \nopenbazaar.org\n or install the \ndaemon\n and \nclient\n from source from their various Github repos. Instructions for installing from source can be found in each repo.  \n\n\nContributing\n\n\nOpenBazaar is an open source project and we welcome contributions of all types. If you are a developer feel free to submit issues or pull requests to both the openbazaar-go and openbazaar-desktop repos. If you want to contribute to this documentation, it can be found \non github\n. We welcome you to file issues and submit pull requests to help us improve this documentation.", 
            "title": "About"
        }, 
        {
            "location": "/#what-is-openbazaar", 
            "text": "OpenBazaar is a new way to buy and sell goods and services online. By running a program on your computer, you can connect directly to other users in the OpenBazaar network and trade with them. The network isn't controlled by a company or organization. OpenBazaar is a decentralised peer-to-peer network, which means there are no listing fees and the marketplace is censorship-resistant.  Goods and services are bought and sold on OpenBazaar using Bitcoin, a digital cryptocurrency that is decentralised and censorship-resistant. Transaction fees on the Bitcoin network are very cheap.  Bitcoin and OpenBazaar together make online commerce cheaper and more free than ever before.  Right now, online commerce means using centralized services. eBay, Amazon, Alibaba and others have restrictive policies and charge fees for listing and selling goods. They only accept forms of payment that cost both buyers and sellers money, such as credit cards or PayPal/Alipay. They require personal information, which can lead to it being stolen or even sold to others for advertising or worse. Buyers and sellers aren\u2019t always free to exchange goods and services with each other, as companies and governments censor entire categories of trade.  OpenBazaar is a different approach to online commerce. It puts the power back in the users\u2019 hands. Instead of buyers and sellers going through a centralized service, OpenBazaar connects them directly. Because there is no one in the middle of the transactions, there are no fees, no one can censor transactions, and you only reveal the personal information that you choose.  This project is open source, which means the code is publicly available for people to review or audit, as well as contribute code to make it better.", 
            "title": "What is OpenBazaar?"
        }, 
        {
            "location": "/#about-this-documentation", 
            "text": "This developer reference aims to provide you with a technical understanding of how OpenBazaar works as well as document, in detail, the OpenBazaar protocol specification. The reference implementation of the OpenBazaar protocol is  openbazaar-go , server daemon written in the  Go  programming language.   While the openbazaar-go API is not part of the formal protocol spec, it is also documented here along with a number of examples to help you start building apps on top of the protocol.", 
            "title": "About this documentation"
        }, 
        {
            "location": "/#running-openbazaar", 
            "text": "The reference implementation is technically two separate applications \u2015 a  daemon  which silently runs in the background and a user-interface which communicates with the running daemon. The  daemon  is the application which does all of the heavy-lifting. Among other things, it maintains peer to peer network connections, serves a user's product listings to other peers when requested, processes incoming orders and bitcoin transactions, and fetches content from other peers when you ask it to.   The user interface, or client, runs in a packaged Chromium browser (see  electron ) and communicates with the daemon via an API.  A typical install of OpenBazaar bundles both the openbazaar-go daemon and user interface into a single application and launches both at the same time. From the user's perspective, it appears to be a single application.  The reason for this modular design is to make it easy for power users to run the openbazaar-go daemon on a separate device, perhaps a server, and keep it running 24/7 if they desire. In this configuration a user only needs the client installed on their computer and can connect it to the daemon via the internet.   If you have not already done so, we suggest you download OpenBazaar and check it out. You can download the full (bundled) application from  openbazaar.org  or install the  daemon  and  client  from source from their various Github repos. Instructions for installing from source can be found in each repo.", 
            "title": "Running OpenBazaar"
        }, 
        {
            "location": "/#contributing", 
            "text": "OpenBazaar is an open source project and we welcome contributions of all types. If you are a developer feel free to submit issues or pull requests to both the openbazaar-go and openbazaar-desktop repos. If you want to contribute to this documentation, it can be found  on github . We welcome you to file issues and submit pull requests to help us improve this documentation.", 
            "title": "Contributing"
        }, 
        {
            "location": "/overview/", 
            "text": "High level Overview\n\n\nOpenBazaar is the product of merging several advanced peer-to-peer or distributed technologies. Specifically, it uses a modified IPFS node (which combines ideas from Git, BitTorrent, and Kademlia), the digital currency Bitcoin, and Ricardian Contracts.\n\n\nSeeding Content\n\n\nWhen a user opens an OpenBazaar store, they \nseed\n their store data (the product listings, images, etc) in a way that might be familiar to anyone who has ever used BitTorrent. Potential buyers can view this store by making a direct connection to the seller and downloading the available product listings. Like BitTorrent, once a user downloads content from other peers, they start seeding that content as well. Through this process, user data quickly becomes replicated on multiple nodes in the network. The next time someone attempts to view that content, he can download it from any of the users who have it, not limited to only the originating node. For larger files users can download pieces from multiple peers simultaneously, increasing the speed of the download. \n\n\nThis network architecture causes downloads to behave differently than the traditional client-server model. Whereas downloads in a client-server model slow down when the server comes under heavy load, downloads in OpenBazaar actually speed up in such circumstances. This is due to the sharding of files into smaller pieces and nodes sharing them as soon as they are downloaded, without waiting for the full file to download. \n\n\nReplicating data across multiple nodes also makes the data more resistant to censorship than the traditional client-server model. Taking a store offline isn't simply a matter of locating a server and performing a denial of service attack. In our case, the data can persist whether the originating node is online or not. \n\n\nContracts\n\n\nIf a buyer decides to make a purchase, a signed order message is sent to the vendor (the vendor can be offline at this point as there is a means to recover messages sent to you while you're offline). The buyer has the option of to pay for the order by sending bitcoins either directly to the vendor or by funding an escrow address (more on this in a minute). The orders are recorded in a cryptographic data structure known as a Ricardian Contract. Any further messages sent between the buyer and vendor, such as the order confirmation or order fulfillment messages, are recorded in the contract providing a cryptographic record of the order's history. \n\n\nEscrow\n\n\nUnlike centralized eCommerce platforms, in OpenBazaar there isn't any company that can provide arbitration services if a contract is breached. However, this ends up being a strength of the platform as it allows for the creation of a market for such arbitration services. In OpenBazaar, the term \"moderator\" is used to represent a user who offers escrow/arbitration services to users of the network. \n\n\nVendors have the option to select one or more moderators when creating listings. The vendor's choice of moderator(s) should be considered part of the bundle of goods offered up for sale. If a buyer does not recognize any of the moderators or does not believe any of them to be trustworthy, then he should not purchase the item. \n\n\nWhen a buyer makes a moderated purchase, the funds go into a bitcoin escrow address. Unlike traditional escrow, where a single person (or group) is trusted to keep the funds safe (and not steal them!), funds locked in a bitcoin escrow address cannot be removed from escrow without the cryptographic signatures of two of the three parties involved (buyer, vendor, and moderator). This requirement prevents theft in the event an untrustworthy moderator is chosen. \n\n\nIf the order is completed successfully the buyer and vendor can sign to release the funds from the escrow to the vendor. If either party is unsatisfied, they can open a dispute with the moderator. The moderator, in combination with either the buyer or vendor, can sign to release the funds to whichever party wins the dispute. \n\n\nDistributed Hash Tables\n\n\nA distributed hash table (DHT) is a distributed key/value database. Unlike a traditional database which might store data on a single computer, a DHT distributes the data across nodes in a peer-to-peer network. Consider the following set of keys and values:\n\n\n\n\nIf a user wants to store \nPaul={\"Computers, \"Programming\"}\n in the DHT, he would connect to the peer-to-peer network and issue a \nSTORE\n command to one or more nodes. Now anyone could retrieve that value by querying the network using the key \nPaul\n and they will get back \n{\"Computers, Programming\"}\n.\n\n\nThe trick here is making this DHT scalable so that it can handle large amounts of data. Having every node store all the data would scale very poorly. Therefore DHTs are designed to split the data set into shards and have only a subset of nodes store a shard. Once you do this the challenge then becomes figuring out which specific nodes to issue the \nSTORE\n command to so that someone querying the network for a key can figure out which nodes they have to query to retrieve the data. \n\n\nThere are different ways to accomplish this task and a number of different designs have been proposed and implemented. In OpenBazaar, the specific DHT design used is \nKademlia\n. \n\n\nKademlia\n\n\nPrior to joining a Kademlia DHT each node creates a unique identifier, or peer ID. Typically this can just be a long random number, but in OpenBazaar it's a SHA256 hash of an RSA public key. This identifier also serves as an OpenBazaar user ID and corresponding public key allows the user to sign messages which can be validated against the ID.\n\n\nThe following is an example of a typical network topology. In this example, we've substituted the long SHA256 IDs for small integer IDs just to make it easier for us to visualize and reason about. Notice how the network is linear, with the smallest peer ID on the left and the largest on the right. In the actual OpenBazaar network, this range of possible IDs runs from 0 (on the left) to 2\n256\n (on the right).\n\n\n\n\nRouting Tables\n\n\nEach node maintains a \nrouting\n \ntable\n which contains a list of peers (ID and IP address) that it knows about. We again run into scalability issues if each node attempts store \nall\n nodes in its routing table. Therefore each node only stores a subset of the total nodes in its routing table giving it only a \npartial\n view of the network. \n\n\nHowever, it's not sufficient to choose which nodes to store or not at random. Instead, each node makes a decision whether to add a node to its routing table based on an algorithm. The goal of this algorithm is to ensure that the node has a fairly complete view of the other nodes that are \"close\" to it and a less complete, or partial, view of the nodes that \"further\" away.\n\n\nWhat do we mean by \"close\"? We're not talking about physical distance (such as Node 14 is in Chicago and Node 38 is in Hong Kong). Instead, we are going to define \ndistance\n in terms of each node's peer ID. One way to do this could be to use absolute value. For example, the \"distance\" between Node 14 and Node 38 would be 24 (|14 - 38| = 24). However, in Kademlia we use the xor(\u2295) operation to determine distance. For example, the \"distance\" between Node 14 and Node 38, when measured by the xor metric, is 40 (14 \u2295 38 = 40 and also 38 \u2295 14 = 40).\n\n\nNow that we have an idea what we mean by \"close\", we can proceed to define our algorithm. The routing table starts out containing only a single \nbucket\n which can hold at most \nK\n peers. The \nK\n parameter is selected as a tradeoff between efficiency and data redundancy. Typically it's set to 20 as research suggest that number is close to optimal. Every bucket has a \nrange\n of peer IDs that it covers. For the sake of this example, let's suppose the range of our peer IDs is 0 to 99 (again a real network would be 0 to 2\n256\n).\n\n\nEach time a node learns of a new peer (this tends to happen automatically peers will contact you periodically looking for data) it adds that peer to the bucket. If the bucket is full (meaning it already has 20 peers in it), the algorithm splits the bucket into two separate buckets as follows:\n\n\n\n\nAnd the new peer would be added to the bucket whose range it ID falls within. For example, if we were adding peer 19, it would be added to bucket 0. Now that we have more than one bucket, the decision about what to do when a bucket gets full is slightly different. If the ID of the peer falls within a bucket whose range \nour\n node's ID also falls (we could call this our \nneighborhood\n), then we split the bucket just like in our previous example. If the bucket's range does not encompass \nour\n node ID, then we don't add the peer to our routing table. \n\n\nAs an example, suppose our Node ID is 29. We fall within the range of bucket 0. Further, suppose we are considering whether we should add Node 74 to our routing table. Node 74 falls within bucket 1 but bucket 1 is full. In this case, we do \nnot\n add Node 74 since it falls in a full bucket that is different from the bucket our Node ID would fall within. \n\n\nIf we were to consider adding node 42 to bucket 0 but bucket 0 is full, we would \nsplit\n bucket 0 into two separate buckets because that is the bucket whose range our own ID falls within. \n\n\nThrough this algorithm we ensure that only peers that are \"close\" to us are added to the routing table, while exponentially fewer peers are stored the farther away they are. Below we have an example of a routing table for a network with a range of 0 to 2\n160\n.\n\n\n\n\nBootstrapping\n\n\nLet's go back to our original example. Suppose we've generated a peer ID 81, how do we actually join the network? Like all peer-to-peer networks, we need to know the IP address of at least a few node's in the network in order to join. These IP addresses can be hard-coded in the software or could be fetched from a seed server. In either case, the first thing we're going to need to do is populate our routing table. How do we do this?\n\n\nSuppose one of the bootstrap nodes we use is Node 5. What we're going to do is connect to Node 5 and say, \"Give me the 3 nodes in your routing table that are closest to Node 81\". And Node 5 would respond with the IP addresses of those three nodes, let's say Nodes 20, 26, and 38. This is called a \nFIND NODE\n command. Again, each time we learn of a new node, we add that node to our routing table according to the algorithm we described above.\n\n\nNow we can go to Nodes 20, 26, and 38 and issue \nthem\n \nFIND NODE\n commands and they will, presumably, respond with nodes that are closer still to ID 81. We can keep making these iterative \nFIND NODE\n queries (sometimes called a \ncrawl\n) until the nodes we get back are no closer to 81 than the closest node in our routing table. At this point, we can stop the crawl and have successfully bootstrapped our routing table. \n\n\n\n\nStoring Data\n\n\nSuppose we want to store a key/value pair in the network. How do we do it? First, we hash the key with SHA256. Continuing from our example above, if the key we want to insert is \"Paul\" then we do:\n\n\nkey = SHA256(\nPaul\n) // 818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a\n\n\n\n\nOur goal is to find the \nK\n closest nodes (against K is usually 20) to the \nkey\n and give them both the key and value to store by issuing a \nSTORE\n command.\n\n\nHow do we find the 20 closest nodes to the key? By doing the same type of iterative \nFIND NODE\n crawl we did above. The only difference this time is we select the initial 4 nodes to query from our routing table (the 4 closest nodes to the key) instead of using the list of bootstrap peers. \n\n\nUpon completion of the crawl we should we should have the IP addresses of the 20 closest nodes and can issue \nSTORE(key, value)\n or in our example, \nSTORE(818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a, {\"Computers, \"Programming\"})\n.\n\n\nFetching Data\n\n\nIt should be fairly easy at this point to see how we will get the value back out of the DHT. If someone knows a key, \"Paul\" for example. Just like before, they can calculate:\n\n\nkey = SHA256(\nPaul\n) // 818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a\n\n\n\n\nHowever, instead of a \nFIND NODE\n crawl, they will do a \nFIND VALUE\n crawl. This type of command behaves just like a \nFIND NODE\n command except we give the remote peer the key we are looking for. If they have the corresponding value, they will return it to us. If not, they return the 3 closest peers just like in a \nFIND NODE\n command. By the end of the crawl, we should have the value if it existed in the DHT.\n\n\nEnsuring Persistence\n\n\nAs we already mentioned, \nSTORE\n commands are issued to \nK\n nodes instead of just one. This is to ensure that the data is replicated on more than one node and to guard against losing data when nodes go offline. \n\n\nIn addition, nodes need to be programmed to proactively share values with new nodes as they join the network. When a node learns of a new node in its neighborhood, it should share any values whose keys are close enough to the new node that it should be storing them. \n\n\nIn this way, a DHT can be said to be \"self-healing\" in that the network can withstand fairly high node churn and still keep values alive. \n\n\nThe OpenBazaar DHT\n\n\nWhile the value one stores in a DHT could be arbitrary data, such as images, product listings, or chat messages, in OpenBazaar we only store \npointers\n to this data in the DHT. A pointer is not the data itself, but rather a list of IP address of nodes that have the value. In other words, a pointer \npoints\n to the nodes that have the value. For example:\n\n\nvalue = [\n    {\n        \npeerID\n: QmNedYJ6WmLhacAL2ozxb4k33Gxd9wmKB7HyoxZCwXid1e,\n        \naddresses\n: [\n            \n/ip4/103.2.117.6/tcp/4001\n,\n            \n/ip4/127.0.0.1/tcp/4001\n,\n            \n/ip6/2001:0000:3238:DFE1:63:0000:0000:FEFB/tcp/4001\n,\n            \n/ip6/::1/tcp/4001\n\n        ]\n    },\n    {\n        \npeerID\n: QmamudHQGtztShX7Nc9HcczehdpGGWpFBWu2JvKWcpELxr,\n        \naddresses\n: [\n            \n/ip4/202.55.147.10/tcp/4001\n,\n            \n/ip4/127.0.0.1/tcp/4001\n,\n            \n/ip6/3ffe:1900:4545:3:200:f8ff:fe21:67cf/tcp/4001\n,\n            \n/ip6/::1/tcp/4001\n\n        ]\n    },\n    {\n        \npeerID\n: QmbyUYWZEBRFw9uxVThS4FYMwkdhWfGAsYwppBKTF6L968,\n        \naddresses\n: [\n            \n/ip4/192.231.203.130/tcp/4001\n,\n            \n/ip4/127.0.0.1/tcp/4001\n\n        ]\n    }\n]\n\n\n\n\nThere are several reasons why it is preferable to store pointers as values rather than the full data:\n\n\n\n\n\n\nFar more people can be storing the actual data. DHT data is only stored by \nK\n nodes that place a hard limit on the amount of data replication we can have. If we only store pointers in the DHT, there is no limit to the number of nodes who can store the data.\n\n\n\n\n\n\nBecause each node has to regularly share its data with other nodes (such as when new nodes join the network), the DHT could end up using enormous amounts of bandwidth if it had to share, say images or videos with such regularity. It's much less of a burden for a node to share tiny pointers.\n\n\n\n\n\n\nNo node in the DHT is forced to store content which they do not wish to store. For example, if we allowed storage of arbitrary data, you could end up storing illicit or illegal content against your will, which could get \nyou\n in trouble just for running the software.\n\n\n\n\n\n\nSince OpenBazaar is only storing \npointers\n in the DHT we generally refer to the DHT as our routing layer since it's used to route download requests to the appropriate nodes.\n\n\nSeeding Files\n\n\nIn OpenBazaar one can \"seed\" a file by inserting the hash of the file into the DHT as the key and a pointer to one's node (peerID and IP addresses) as the value. The nodes that receive the \nSTORE\n command will \nappend\n the pointer to the list of pointers it is storing for that key. Anyone else can download the file if they know the hash by querying the DHT for the hash then using the returned pointers to connect to one or more of the peers seeding the file to download it. Seeders periodically re-publish their pointers to ensure persistence. \n\n\nIPFS\n\n\nIPFS\n stands for Interplanetary File System. It is a hypermedia distribution protocol which forms the core the OpenBazaar network. It uses a Kademlia DHT, exactly as described above, to route downloaders to those seeding files. What makes it unique is how IPFS serializes the data to create a cryptographically authenticated data structure known as a \nMerkle\n \nDAG\n. \n\n\n[Note: much of this description of IPFS is taken verbatim from \nChristian Lundkvist\n since he did such a great job]\n\n\nIPFS Objects\n\n\nBefore data is seeded it is wrapped in an IPFS object. Objects have two fields:\n\n\n\n\nData\n - a blob of unstructured binary data of size \n 256 kB.\n\n\nLinks\n - an array of Link structures. These are links to other IPFS objects.\n\n\n\n\nA Link structure has three data fields:\n\n\n\n\nName\n - the name of the Link.\n\n\nHash\n - the hash of the linked IPFS object.\n\n\nSize\n - the cumulative size of the linked IPFS object, including following its links.\n\n\n\n\nIPFS objects are referred to by their hash, which is encoded in a Base58 multihash format. For example, \nQmarHSr9aSNaPSR6G9KFPbuLV9aEqJfTk1y9B8pdwqK4Rq\n. \n\n\nSo an IPFS object may look something like this:\n\n\n{\n  \nLinks\n: [\n    {\n      \nName\n: \nAnotherName\n,\n      \nHash\n: \nQmVtYjNij3KeyGmcgg7yVXWskLaBtov3UYL9pgcGK3MCWu\n,\n      \nSize\n: 18\n    },\n    {\n      \nName\n: \nSomeName\n,\n      \nHash\n: \nQmbUSy8HCn8J4TMDRRdxCbK2uCCtkQyZtY6XYv3y7kLgDC\n,\n      \nSize\n: 58\n    }\n  ],\n  \nData\n: \nHello World!\n\n} \n\n\n\n\nIt should first be noted that since IPFS objects are referred to by their hash, this data structure is cryptographically authenticated. If I fetch an IPFS object from the DHT by using its hash, I can verify that the data the peers returned to me has not been tampered with. The same goes for each the \"links\" inside the object. Once I download the parent IPFS object, I can proceed to fetch each of the links from the DHT by using their hash and validate them as well. Technically, since each link also contains a \nName\n, our software can actual be told to fetch linked objects by their \nName\n since it can always look up the corresponding \nHash\n in the parent object. \n\n\nWhen we can download a file from anyone on the network by only knowing its hash, we call this \ncontent\n \naddressing\n. This is different from traditional HTTP requests that use \nlocation\n \naddressing\n \u2015 fetching content from a specific location (such as a server).\n\n\nLet's create a visualization of the above IPFS object:\n\n\n\n\nSmall Files\n\n\nSmall files (\n256 kB) are represented as an IPFS object with the file data in the \nData\n field and no \nLinks\n. For example, a text file that says \"Hello World\" would look like this:\n\n\n{\n  \nLinks\n: [],\n  \nData\n: \n\\u0008\\u0002\\u0012\\rHello World!\\n\\u0018\\r\n\n}\n\n\n\n\nAnd in a more visual form:\n\n\n\nLarge Files\n\n\nFiles \n256 kB in size are split into chunks no larger than 256 kB and these chunks are linked to by the parent IPFS object (with filenames omitted). For example:\n\n\n{\n  \nLinks\n: [\n    {\n      \nName\n: \n,\n      \nHash\n: \nQmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB\n,\n      \nSize\n: 262158\n    },\n    {\n      \nName\n: \n,\n      \nHash\n: \nQmQeUqdjFmaxuJewStqCLUoKrR9khqb4Edw9TfRQQdfWz3\n,\n      \nSize\n: 262158\n    },\n    {\n      \nName\n: \n,\n      \nHash\n: \nQma98bk1hjiRZDTmYmfiUXDj8hXXt7uGA5roU5mfUb3sVG\n,\n      \nSize\n: 178947\n    }\n  ],\n  \nData\n: \n\\u0008\\u0002\\u0018\ufffd\ufffd* \ufffd\ufffd\\u0010 \ufffd\ufffd\\u0010 \ufffd\ufffd\\n\n\n}\n\n\n\n\n\n\nWhen downloading large files, we don't have to download all links from the same node. Instead, we can download the links concurrently, from separate nodes, and dramatically increase the download speed. \n\n\nDirectories\n\n\nIt's not hard to see how IPFS objects could be used to represent a file directory. Consider the following directory structure:\n\n\n.\n|--test_dir:\n|  |--my_dir:\n|  |  |--my_file.txt\n|  |  `--testing.txt\n|  |--bigfile.js\n|  `--hello.txt\n\n\n\n\nThe files hello.txt and my_file.txt both contain the string Hello World!\\n. The file testing.txt contains the string Testing 123\\n.\n\n\nWhen representing this directory structure as an IPFS object it looks like this:\n\n\n\nVersioning\n\n\nIPFS can represent the data structures used by Git to allow for versioned file systems. A \nCommit\n object has one or more links with names parent0, parent1 etc pointing to previous commits, and one link with name object (this is called tree in Git) that points to the file system structure referenced by that commit.\n\n\nWe give as an example our previous file system directory structure, along with two commits: The first commit is the original structure, and in the second commit we\u2019ve updated the file my_file.txt to say Another World! instead of the original Hello World!.\n\n\n\n\nIPFS in OpenBazaar\n\n\nIn OpenBazaar we store all user data \u2015 profiles, listings, product images, reviews, channels, etc \u2015 are stored in a directory referred to as the user's \nroot\n directory. All of the user's files are stored either in the \nroot\n directory or any of its subdirectories. This \nroot\n directory is seeded on the network along with all the directories files and subdirectories. By seeding data in this manner, we only need to know the hash of a user's \nroot\n directory in order to download and view all the content that makes up the user's page or store. \n\n\nFor example, an API call of \nipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt\n allows us to look inside a root directory:\n\n\n\n\nAnd if we wanted to look inside the \nlistings\n subdirectory we could call: \nipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt/listings/\n\n\n\n\nNote that in the above API call, we only needed to use the \nName\n (/listing) and not the hash of the listing directory since the software will look up the \nHash\n from the \nName\n.\n\n\nAnd finally we could fetch the data for the \ncool-t-shrit\n listing with the following call: \nipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt/listings/cool-t-shirt.json\n\n\nIPNS\n\n\nThus far we've seen how we can fetch a user's content given the hash of his \nroot\n directory, but we have a bit of a problem. The \nHash\n of the \nroot\n directory changes every time we change the existing files or add new data. If we gave out our \nroot\n hash to people so they can view our store, the hash would be made obsolete the next time up updated any data in our root directory (such as changing the price of a listing). \n\n\nIPNS stands for Interplanetary Naming System. It is a self-authenticating namespace built on top of IPFS. What we can do with IPNS is cryptographically map the hash of our \nroot\n directory to our \npeerID\n. This is accomplished by signing the hash of the \nroot\n directory with our identity key (remember the RSA key we mentioned earlier) and insert this signed hash into the DHT using our peerID as the key. \n\n\nSo inside the DHT we have a record that looks like:\n\n\npeerID = signed(rootHash)\n\n\n\n\nAnd since our peerId is the SHA256 hash of our RSA public key, anyone can fetch the latest copy of our \nroot\n hash from the DHT and validate the signature against our public key, which itself should hash to our \npeerID\n. \n\n\nIn this manner, one only needs to know our \npeerID\n to download an authenticated copy of all of our store content. \n\n\nUsing the IPNS protocol the above API call which fetched the listing could be rewritten as \n/ipns/QmdHkAQeKJobghWES9exVUaqXCeMw8katQitnXDKWuKi1F/listings/coot-t-shirt.json\n where \nQmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt\n is our \npeerID\n.\n\n\nAnd by using other naming protocols such as \nBlockstack\n we can cryptographically map a user's \npeerID\n, which is a rather ugly looking series of numbers and letters, to a more human readable username such as \n@UrbanArt\n. Thus one only needs to know the human readable username to download user content in a cryptographically secure manner. \n\n\nBitcoin\n\n\nThe digital currency Bitcoin is used in OpenBazaar as the primary means of payment. The reason for this choice is two-fold. First, it aligns well with the goals of the project to be a decentralized, censorship-resistant eCommerce platform without a middle man. Bitcoin is also decentralized, censorship-resistant, and has no middlemen. It also has very low transaction fees compared to other forms of payment. Presently a bitcoin transaction can be made for about 10\u00a2 USD compared to about 30\u00a2 \nplus\n 2.9% of the total for PayPal. Credit cards similarly take a percentage of the transaction. And, of course, those methods of payment can be tracked and censored if need be. \n\n\nWe should supplement the previous statement on fees slightly. If a user wishes to convert bitcoins he earned from selling on OpenBazaar to fiat currency, he likely will incur some additional fees for the currency conversion. However, presently the company \nCoinbase\n allows vendors to convert up to $1 million USD for free and at a 1% fee for everything over $1 million. Which is to say, even when factoring in currency conversion, Bitcoin can still be far cheaper than the alternatives (and of course there are zero fees to sell on OpenBazaar). \n\n\nThe second reason Bitcoin is a good choice is it allows us to build the trustless escrow system we mentioned earlier. All other forms of payment require you to use the payment provider (such as PayPal) for arbitration if you have a dispute. With Bitcoin, we can not only create a free market for escrow/arbitration services, but we can do so in such a way as to remove the risk that the escrow agent will steal (or lose) the funds. \n\n\nMultisig scripts\n\n\nIf you like to learn more about how Bitcoin works we'd suggest reading the \nBitcoin Developer Guide\n. However, we can provide a quick overview of how the escrow system works. \n\n\nIn Bitcoin, the coins are not technically sent to a bitcoin \"address\" or account. Instead, they are sent to a tiny computer program (or script). This script sets the terms upon which the coins are allowed to be transferred. A person seeking to spend bitcoins provides the inputs to the script function and the bitcoin software will execute it. If the script returns \nTrue\n (and all other transaction checks pass) then the bitcoins may be transferred to another script. \n\n\nThe specific script we use looks something like this:\n\n\nOP_HASH160 \nHash160(redeemScript)\n OP_EQUAL\n\n\n\n\nTechnically this script means \"anyone who knows a certain password can spend these coins\", however Bitcoin underwent a soft-fork upgrade several years ago which gives this script a \"special\" meaning. In essence, when the interpreter sees this script it interprets it, not as a password script, but as something called \"pay to script hash\" or P2SH.\n\n\nCoins sent to this script can be spent by providing a \nredeem script\n whose hash matches the hash in the output script and then by fulfilling the terms of the \nredeem script\n.\n\n\nIn OpenBazaar we use a redeem script that looks like:\n\n\nOP_2 \nbuyer_pubkey\n \nvendor_pubkey\n \nmoderator_pubkey\n OP_3 OP_CHECKMULTISIG\n\n\n\n\nThis script says the funds may be transferred if signatures matching two of the three listed public keys are provided.\n\n\nThe scripting language is flexible enough that we could extend it with additional features in the future. For example, suppose we want to add a timeout to the escrow. That is, if the buyer doesn't release the fund or file a dispute within 60 days, the funds will then be transferred to the vendor. Essentially this can save the vendor some headaches trying to collect his payment. \n\n\nThis redeem script would look like:\n\n\nOP_IF\n    OP_2 \nbuyer_pubkey\n \nvendor_pubkey\n \nmoderator_pubkey\n OP_3 OP_CHECKMULTISIG\nOP_ELSE\n   \n60d\n OP_CHECKSEQUENCEVERIFY OP_DROP\n    \nvendor_pubkey\n OP_CHECKSIG\nOP_ENDIF\n\n\n\n\nBitcoin Wallets\n\n\nThe OpenBazaar protocol specification has nothing to say about which Bitcoin wallet should be used with the protocol. However, to improve the user experience, the reference implementation comes bundled with a built-in wallet. The default wallet implements something call Simplified Payment Verification (SPV) which provides strong cryptographic validation of incoming Bitcoin transactions while using very little of the computer's resources. The drawback to SPV mode is it leaks enough private data to allow potential attackers to figure out which transactions came from the wallet. Although that information by itself doesn't say who the \nowner\n of the wallet is (other investigative techniques might provide that information, however). \n\n\nFor this reason, there is a setting in the openbazaar-go config file that allows a user to use bitcoind (a full Bitcoin implementation) with openbazaar-go. Bitcoind is a very heavyweight software and is typically only used by power users, but it does a much better job than SPV at providing transactional privacy. \n\n\nAltcoins\n\n\nThere isn't anything Bitcoin-specific about Kademlia, IPFS, or Ricardian Contracts. In theory, the OpenBazaar protocol could work with any digital currency, not just Bitcoin. In practice, there are certain features a digital currency must have to be used with the OpenBazaar protocol that not every altcoin has. For example, an altcoin must support multisignature transactions else the escrow system will not work. The protocol also makes some assumptions about the existence of payment addresses and transaction inputs and outputs. These assumptions could probably be abstracted away in future versions of the protocol, but it stands to reason that altcoins that are a close derivative to Bitcoin would work better with the OpenBazaar protocol than coins that are a dramatic departure from it. \n\n\nRicardian Contracts\n\n\nA traditional contract is a written or spoken agreement among two (or more) parties to exchange something of value. Every time we transact for anything we are entering into a legally binding contract, even if they are only verbal. When you purchase things on the internet, you are likewise entering into a legally binding contract. However, contracts are sometimes poorly written, ambiguous or difficult to interpret. They may be subject to \nfrog-boiling\n where a strong party attempts to change the contract over time in his favor or even to one party denying they agreed on the contract. These issues can make it difficult for arbitrators to determine who is correct in a dispute. \n\n\nA Ricardian Contract is a type of cryptographic contract that attempts to solve these problems. Ricardian contracts a both human readable and machine parsable and provides an irrefutable record of what both parties agree to. It's not clear whether a Ricardian Contract would be treated as a valid contract in court (it would likely vary by jurisdiction anyway) but it doesn't matter as the terms of the contract can be enforced programmatically by software. \n\n\nIn OpenBazaar the Ricardian Contract looks as follows:\n\n\nsyntax = \nproto3\n;\n\nmessage RicardianContract {\n    repeated Listing vendorListings                    = 1;\n    Order buyerOrder                                   = 2;\n    OrderConfirmation vendorOrderConfirmation          = 3;\n    repeated OrderFulfillment vendorOrderFulfillment   = 4;\n    OrderCompletion buyerOrderCompletion               = 5;\n    Dispute dispute                                    = 6;\n    DisputeResolution disputeResolution                = 7;\n    Refund refund                                      = 8;\n    repeated Signature signatures                      = 9;\n}\n\n\n\n\nEach section of the contract is signed by the appropriate party's identity key. For example, the vendor signs the \nListing\n object while the buyer signs the \nOrder\n object. As the order progresses through different states, new objects are appended to the contract along with their signatures. When a dispute is filed with a moderator, the contract is sent to the moderator, programmatically validated, and then marshaled to JSON for the moderator to read. The contract contains all the information a moderator needs to make a decision and doesn't provide any wiggle room for the buyer and vendor to try to manipulate the outcome. \n\n\nThe Ricardian Contract structure is very extensible and allows virtually an unlimited number of contract types to be created.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#high-level-overview", 
            "text": "OpenBazaar is the product of merging several advanced peer-to-peer or distributed technologies. Specifically, it uses a modified IPFS node (which combines ideas from Git, BitTorrent, and Kademlia), the digital currency Bitcoin, and Ricardian Contracts.", 
            "title": "High level Overview"
        }, 
        {
            "location": "/overview/#seeding-content", 
            "text": "When a user opens an OpenBazaar store, they  seed  their store data (the product listings, images, etc) in a way that might be familiar to anyone who has ever used BitTorrent. Potential buyers can view this store by making a direct connection to the seller and downloading the available product listings. Like BitTorrent, once a user downloads content from other peers, they start seeding that content as well. Through this process, user data quickly becomes replicated on multiple nodes in the network. The next time someone attempts to view that content, he can download it from any of the users who have it, not limited to only the originating node. For larger files users can download pieces from multiple peers simultaneously, increasing the speed of the download.   This network architecture causes downloads to behave differently than the traditional client-server model. Whereas downloads in a client-server model slow down when the server comes under heavy load, downloads in OpenBazaar actually speed up in such circumstances. This is due to the sharding of files into smaller pieces and nodes sharing them as soon as they are downloaded, without waiting for the full file to download.   Replicating data across multiple nodes also makes the data more resistant to censorship than the traditional client-server model. Taking a store offline isn't simply a matter of locating a server and performing a denial of service attack. In our case, the data can persist whether the originating node is online or not.", 
            "title": "Seeding Content"
        }, 
        {
            "location": "/overview/#contracts", 
            "text": "If a buyer decides to make a purchase, a signed order message is sent to the vendor (the vendor can be offline at this point as there is a means to recover messages sent to you while you're offline). The buyer has the option of to pay for the order by sending bitcoins either directly to the vendor or by funding an escrow address (more on this in a minute). The orders are recorded in a cryptographic data structure known as a Ricardian Contract. Any further messages sent between the buyer and vendor, such as the order confirmation or order fulfillment messages, are recorded in the contract providing a cryptographic record of the order's history.", 
            "title": "Contracts"
        }, 
        {
            "location": "/overview/#escrow", 
            "text": "Unlike centralized eCommerce platforms, in OpenBazaar there isn't any company that can provide arbitration services if a contract is breached. However, this ends up being a strength of the platform as it allows for the creation of a market for such arbitration services. In OpenBazaar, the term \"moderator\" is used to represent a user who offers escrow/arbitration services to users of the network.   Vendors have the option to select one or more moderators when creating listings. The vendor's choice of moderator(s) should be considered part of the bundle of goods offered up for sale. If a buyer does not recognize any of the moderators or does not believe any of them to be trustworthy, then he should not purchase the item.   When a buyer makes a moderated purchase, the funds go into a bitcoin escrow address. Unlike traditional escrow, where a single person (or group) is trusted to keep the funds safe (and not steal them!), funds locked in a bitcoin escrow address cannot be removed from escrow without the cryptographic signatures of two of the three parties involved (buyer, vendor, and moderator). This requirement prevents theft in the event an untrustworthy moderator is chosen.   If the order is completed successfully the buyer and vendor can sign to release the funds from the escrow to the vendor. If either party is unsatisfied, they can open a dispute with the moderator. The moderator, in combination with either the buyer or vendor, can sign to release the funds to whichever party wins the dispute.", 
            "title": "Escrow"
        }, 
        {
            "location": "/overview/#distributed-hash-tables", 
            "text": "A distributed hash table (DHT) is a distributed key/value database. Unlike a traditional database which might store data on a single computer, a DHT distributes the data across nodes in a peer-to-peer network. Consider the following set of keys and values:   If a user wants to store  Paul={\"Computers, \"Programming\"}  in the DHT, he would connect to the peer-to-peer network and issue a  STORE  command to one or more nodes. Now anyone could retrieve that value by querying the network using the key  Paul  and they will get back  {\"Computers, Programming\"} .  The trick here is making this DHT scalable so that it can handle large amounts of data. Having every node store all the data would scale very poorly. Therefore DHTs are designed to split the data set into shards and have only a subset of nodes store a shard. Once you do this the challenge then becomes figuring out which specific nodes to issue the  STORE  command to so that someone querying the network for a key can figure out which nodes they have to query to retrieve the data.   There are different ways to accomplish this task and a number of different designs have been proposed and implemented. In OpenBazaar, the specific DHT design used is  Kademlia .", 
            "title": "Distributed Hash Tables"
        }, 
        {
            "location": "/overview/#kademlia", 
            "text": "Prior to joining a Kademlia DHT each node creates a unique identifier, or peer ID. Typically this can just be a long random number, but in OpenBazaar it's a SHA256 hash of an RSA public key. This identifier also serves as an OpenBazaar user ID and corresponding public key allows the user to sign messages which can be validated against the ID.  The following is an example of a typical network topology. In this example, we've substituted the long SHA256 IDs for small integer IDs just to make it easier for us to visualize and reason about. Notice how the network is linear, with the smallest peer ID on the left and the largest on the right. In the actual OpenBazaar network, this range of possible IDs runs from 0 (on the left) to 2 256  (on the right).", 
            "title": "Kademlia"
        }, 
        {
            "location": "/overview/#routing-tables", 
            "text": "Each node maintains a  routing   table  which contains a list of peers (ID and IP address) that it knows about. We again run into scalability issues if each node attempts store  all  nodes in its routing table. Therefore each node only stores a subset of the total nodes in its routing table giving it only a  partial  view of the network.   However, it's not sufficient to choose which nodes to store or not at random. Instead, each node makes a decision whether to add a node to its routing table based on an algorithm. The goal of this algorithm is to ensure that the node has a fairly complete view of the other nodes that are \"close\" to it and a less complete, or partial, view of the nodes that \"further\" away.  What do we mean by \"close\"? We're not talking about physical distance (such as Node 14 is in Chicago and Node 38 is in Hong Kong). Instead, we are going to define  distance  in terms of each node's peer ID. One way to do this could be to use absolute value. For example, the \"distance\" between Node 14 and Node 38 would be 24 (|14 - 38| = 24). However, in Kademlia we use the xor(\u2295) operation to determine distance. For example, the \"distance\" between Node 14 and Node 38, when measured by the xor metric, is 40 (14 \u2295 38 = 40 and also 38 \u2295 14 = 40).  Now that we have an idea what we mean by \"close\", we can proceed to define our algorithm. The routing table starts out containing only a single  bucket  which can hold at most  K  peers. The  K  parameter is selected as a tradeoff between efficiency and data redundancy. Typically it's set to 20 as research suggest that number is close to optimal. Every bucket has a  range  of peer IDs that it covers. For the sake of this example, let's suppose the range of our peer IDs is 0 to 99 (again a real network would be 0 to 2 256 ).  Each time a node learns of a new peer (this tends to happen automatically peers will contact you periodically looking for data) it adds that peer to the bucket. If the bucket is full (meaning it already has 20 peers in it), the algorithm splits the bucket into two separate buckets as follows:   And the new peer would be added to the bucket whose range it ID falls within. For example, if we were adding peer 19, it would be added to bucket 0. Now that we have more than one bucket, the decision about what to do when a bucket gets full is slightly different. If the ID of the peer falls within a bucket whose range  our  node's ID also falls (we could call this our  neighborhood ), then we split the bucket just like in our previous example. If the bucket's range does not encompass  our  node ID, then we don't add the peer to our routing table.   As an example, suppose our Node ID is 29. We fall within the range of bucket 0. Further, suppose we are considering whether we should add Node 74 to our routing table. Node 74 falls within bucket 1 but bucket 1 is full. In this case, we do  not  add Node 74 since it falls in a full bucket that is different from the bucket our Node ID would fall within.   If we were to consider adding node 42 to bucket 0 but bucket 0 is full, we would  split  bucket 0 into two separate buckets because that is the bucket whose range our own ID falls within.   Through this algorithm we ensure that only peers that are \"close\" to us are added to the routing table, while exponentially fewer peers are stored the farther away they are. Below we have an example of a routing table for a network with a range of 0 to 2 160 .", 
            "title": "Routing Tables"
        }, 
        {
            "location": "/overview/#bootstrapping", 
            "text": "Let's go back to our original example. Suppose we've generated a peer ID 81, how do we actually join the network? Like all peer-to-peer networks, we need to know the IP address of at least a few node's in the network in order to join. These IP addresses can be hard-coded in the software or could be fetched from a seed server. In either case, the first thing we're going to need to do is populate our routing table. How do we do this?  Suppose one of the bootstrap nodes we use is Node 5. What we're going to do is connect to Node 5 and say, \"Give me the 3 nodes in your routing table that are closest to Node 81\". And Node 5 would respond with the IP addresses of those three nodes, let's say Nodes 20, 26, and 38. This is called a  FIND NODE  command. Again, each time we learn of a new node, we add that node to our routing table according to the algorithm we described above.  Now we can go to Nodes 20, 26, and 38 and issue  them   FIND NODE  commands and they will, presumably, respond with nodes that are closer still to ID 81. We can keep making these iterative  FIND NODE  queries (sometimes called a  crawl ) until the nodes we get back are no closer to 81 than the closest node in our routing table. At this point, we can stop the crawl and have successfully bootstrapped our routing table.", 
            "title": "Bootstrapping"
        }, 
        {
            "location": "/overview/#storing-data", 
            "text": "Suppose we want to store a key/value pair in the network. How do we do it? First, we hash the key with SHA256. Continuing from our example above, if the key we want to insert is \"Paul\" then we do:  key = SHA256( Paul ) // 818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a  Our goal is to find the  K  closest nodes (against K is usually 20) to the  key  and give them both the key and value to store by issuing a  STORE  command.  How do we find the 20 closest nodes to the key? By doing the same type of iterative  FIND NODE  crawl we did above. The only difference this time is we select the initial 4 nodes to query from our routing table (the 4 closest nodes to the key) instead of using the list of bootstrap peers.   Upon completion of the crawl we should we should have the IP addresses of the 20 closest nodes and can issue  STORE(key, value)  or in our example,  STORE(818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a, {\"Computers, \"Programming\"}) .", 
            "title": "Storing Data"
        }, 
        {
            "location": "/overview/#fetching-data", 
            "text": "It should be fairly easy at this point to see how we will get the value back out of the DHT. If someone knows a key, \"Paul\" for example. Just like before, they can calculate:  key = SHA256( Paul ) // 818b5cc5f21d3e6e4e6071c06294528d44595022218446d8b79304d2b766327a  However, instead of a  FIND NODE  crawl, they will do a  FIND VALUE  crawl. This type of command behaves just like a  FIND NODE  command except we give the remote peer the key we are looking for. If they have the corresponding value, they will return it to us. If not, they return the 3 closest peers just like in a  FIND NODE  command. By the end of the crawl, we should have the value if it existed in the DHT.", 
            "title": "Fetching Data"
        }, 
        {
            "location": "/overview/#ensuring-persistence", 
            "text": "As we already mentioned,  STORE  commands are issued to  K  nodes instead of just one. This is to ensure that the data is replicated on more than one node and to guard against losing data when nodes go offline.   In addition, nodes need to be programmed to proactively share values with new nodes as they join the network. When a node learns of a new node in its neighborhood, it should share any values whose keys are close enough to the new node that it should be storing them.   In this way, a DHT can be said to be \"self-healing\" in that the network can withstand fairly high node churn and still keep values alive.", 
            "title": "Ensuring Persistence"
        }, 
        {
            "location": "/overview/#the-openbazaar-dht", 
            "text": "While the value one stores in a DHT could be arbitrary data, such as images, product listings, or chat messages, in OpenBazaar we only store  pointers  to this data in the DHT. A pointer is not the data itself, but rather a list of IP address of nodes that have the value. In other words, a pointer  points  to the nodes that have the value. For example:  value = [\n    {\n         peerID : QmNedYJ6WmLhacAL2ozxb4k33Gxd9wmKB7HyoxZCwXid1e,\n         addresses : [\n             /ip4/103.2.117.6/tcp/4001 ,\n             /ip4/127.0.0.1/tcp/4001 ,\n             /ip6/2001:0000:3238:DFE1:63:0000:0000:FEFB/tcp/4001 ,\n             /ip6/::1/tcp/4001 \n        ]\n    },\n    {\n         peerID : QmamudHQGtztShX7Nc9HcczehdpGGWpFBWu2JvKWcpELxr,\n         addresses : [\n             /ip4/202.55.147.10/tcp/4001 ,\n             /ip4/127.0.0.1/tcp/4001 ,\n             /ip6/3ffe:1900:4545:3:200:f8ff:fe21:67cf/tcp/4001 ,\n             /ip6/::1/tcp/4001 \n        ]\n    },\n    {\n         peerID : QmbyUYWZEBRFw9uxVThS4FYMwkdhWfGAsYwppBKTF6L968,\n         addresses : [\n             /ip4/192.231.203.130/tcp/4001 ,\n             /ip4/127.0.0.1/tcp/4001 \n        ]\n    }\n]  There are several reasons why it is preferable to store pointers as values rather than the full data:    Far more people can be storing the actual data. DHT data is only stored by  K  nodes that place a hard limit on the amount of data replication we can have. If we only store pointers in the DHT, there is no limit to the number of nodes who can store the data.    Because each node has to regularly share its data with other nodes (such as when new nodes join the network), the DHT could end up using enormous amounts of bandwidth if it had to share, say images or videos with such regularity. It's much less of a burden for a node to share tiny pointers.    No node in the DHT is forced to store content which they do not wish to store. For example, if we allowed storage of arbitrary data, you could end up storing illicit or illegal content against your will, which could get  you  in trouble just for running the software.    Since OpenBazaar is only storing  pointers  in the DHT we generally refer to the DHT as our routing layer since it's used to route download requests to the appropriate nodes.", 
            "title": "The OpenBazaar DHT"
        }, 
        {
            "location": "/overview/#seeding-files", 
            "text": "In OpenBazaar one can \"seed\" a file by inserting the hash of the file into the DHT as the key and a pointer to one's node (peerID and IP addresses) as the value. The nodes that receive the  STORE  command will  append  the pointer to the list of pointers it is storing for that key. Anyone else can download the file if they know the hash by querying the DHT for the hash then using the returned pointers to connect to one or more of the peers seeding the file to download it. Seeders periodically re-publish their pointers to ensure persistence.", 
            "title": "Seeding Files"
        }, 
        {
            "location": "/overview/#ipfs", 
            "text": "IPFS  stands for Interplanetary File System. It is a hypermedia distribution protocol which forms the core the OpenBazaar network. It uses a Kademlia DHT, exactly as described above, to route downloaders to those seeding files. What makes it unique is how IPFS serializes the data to create a cryptographically authenticated data structure known as a  Merkle   DAG .   [Note: much of this description of IPFS is taken verbatim from  Christian Lundkvist  since he did such a great job]", 
            "title": "IPFS"
        }, 
        {
            "location": "/overview/#ipfs-objects", 
            "text": "Before data is seeded it is wrapped in an IPFS object. Objects have two fields:   Data  - a blob of unstructured binary data of size   256 kB.  Links  - an array of Link structures. These are links to other IPFS objects.   A Link structure has three data fields:   Name  - the name of the Link.  Hash  - the hash of the linked IPFS object.  Size  - the cumulative size of the linked IPFS object, including following its links.   IPFS objects are referred to by their hash, which is encoded in a Base58 multihash format. For example,  QmarHSr9aSNaPSR6G9KFPbuLV9aEqJfTk1y9B8pdwqK4Rq .   So an IPFS object may look something like this:  {\n   Links : [\n    {\n       Name :  AnotherName ,\n       Hash :  QmVtYjNij3KeyGmcgg7yVXWskLaBtov3UYL9pgcGK3MCWu ,\n       Size : 18\n    },\n    {\n       Name :  SomeName ,\n       Hash :  QmbUSy8HCn8J4TMDRRdxCbK2uCCtkQyZtY6XYv3y7kLgDC ,\n       Size : 58\n    }\n  ],\n   Data :  Hello World! \n}   It should first be noted that since IPFS objects are referred to by their hash, this data structure is cryptographically authenticated. If I fetch an IPFS object from the DHT by using its hash, I can verify that the data the peers returned to me has not been tampered with. The same goes for each the \"links\" inside the object. Once I download the parent IPFS object, I can proceed to fetch each of the links from the DHT by using their hash and validate them as well. Technically, since each link also contains a  Name , our software can actual be told to fetch linked objects by their  Name  since it can always look up the corresponding  Hash  in the parent object.   When we can download a file from anyone on the network by only knowing its hash, we call this  content   addressing . This is different from traditional HTTP requests that use  location   addressing  \u2015 fetching content from a specific location (such as a server).  Let's create a visualization of the above IPFS object:", 
            "title": "IPFS Objects"
        }, 
        {
            "location": "/overview/#small-files", 
            "text": "Small files ( 256 kB) are represented as an IPFS object with the file data in the  Data  field and no  Links . For example, a text file that says \"Hello World\" would look like this:  {\n   Links : [],\n   Data :  \\u0008\\u0002\\u0012\\rHello World!\\n\\u0018\\r \n}  And in a more visual form:", 
            "title": "Small Files"
        }, 
        {
            "location": "/overview/#large-files", 
            "text": "Files  256 kB in size are split into chunks no larger than 256 kB and these chunks are linked to by the parent IPFS object (with filenames omitted). For example:  {\n   Links : [\n    {\n       Name :  ,\n       Hash :  QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB ,\n       Size : 262158\n    },\n    {\n       Name :  ,\n       Hash :  QmQeUqdjFmaxuJewStqCLUoKrR9khqb4Edw9TfRQQdfWz3 ,\n       Size : 262158\n    },\n    {\n       Name :  ,\n       Hash :  Qma98bk1hjiRZDTmYmfiUXDj8hXXt7uGA5roU5mfUb3sVG ,\n       Size : 178947\n    }\n  ],\n   Data :  \\u0008\\u0002\\u0018\ufffd\ufffd* \ufffd\ufffd\\u0010 \ufffd\ufffd\\u0010 \ufffd\ufffd\\n \n}   When downloading large files, we don't have to download all links from the same node. Instead, we can download the links concurrently, from separate nodes, and dramatically increase the download speed.", 
            "title": "Large Files"
        }, 
        {
            "location": "/overview/#directories", 
            "text": "It's not hard to see how IPFS objects could be used to represent a file directory. Consider the following directory structure:  .\n|--test_dir:\n|  |--my_dir:\n|  |  |--my_file.txt\n|  |  `--testing.txt\n|  |--bigfile.js\n|  `--hello.txt  The files hello.txt and my_file.txt both contain the string Hello World!\\n. The file testing.txt contains the string Testing 123\\n.  When representing this directory structure as an IPFS object it looks like this:", 
            "title": "Directories"
        }, 
        {
            "location": "/overview/#versioning", 
            "text": "IPFS can represent the data structures used by Git to allow for versioned file systems. A  Commit  object has one or more links with names parent0, parent1 etc pointing to previous commits, and one link with name object (this is called tree in Git) that points to the file system structure referenced by that commit.  We give as an example our previous file system directory structure, along with two commits: The first commit is the original structure, and in the second commit we\u2019ve updated the file my_file.txt to say Another World! instead of the original Hello World!.", 
            "title": "Versioning"
        }, 
        {
            "location": "/overview/#ipfs-in-openbazaar", 
            "text": "In OpenBazaar we store all user data \u2015 profiles, listings, product images, reviews, channels, etc \u2015 are stored in a directory referred to as the user's  root  directory. All of the user's files are stored either in the  root  directory or any of its subdirectories. This  root  directory is seeded on the network along with all the directories files and subdirectories. By seeding data in this manner, we only need to know the hash of a user's  root  directory in order to download and view all the content that makes up the user's page or store.   For example, an API call of  ipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt  allows us to look inside a root directory:   And if we wanted to look inside the  listings  subdirectory we could call:  ipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt/listings/   Note that in the above API call, we only needed to use the  Name  (/listing) and not the hash of the listing directory since the software will look up the  Hash  from the  Name .  And finally we could fetch the data for the  cool-t-shrit  listing with the following call:  ipfs/QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt/listings/cool-t-shirt.json", 
            "title": "IPFS in OpenBazaar"
        }, 
        {
            "location": "/overview/#ipns", 
            "text": "Thus far we've seen how we can fetch a user's content given the hash of his  root  directory, but we have a bit of a problem. The  Hash  of the  root  directory changes every time we change the existing files or add new data. If we gave out our  root  hash to people so they can view our store, the hash would be made obsolete the next time up updated any data in our root directory (such as changing the price of a listing).   IPNS stands for Interplanetary Naming System. It is a self-authenticating namespace built on top of IPFS. What we can do with IPNS is cryptographically map the hash of our  root  directory to our  peerID . This is accomplished by signing the hash of the  root  directory with our identity key (remember the RSA key we mentioned earlier) and insert this signed hash into the DHT using our peerID as the key.   So inside the DHT we have a record that looks like:  peerID = signed(rootHash)  And since our peerId is the SHA256 hash of our RSA public key, anyone can fetch the latest copy of our  root  hash from the DHT and validate the signature against our public key, which itself should hash to our  peerID .   In this manner, one only needs to know our  peerID  to download an authenticated copy of all of our store content.   Using the IPNS protocol the above API call which fetched the listing could be rewritten as  /ipns/QmdHkAQeKJobghWES9exVUaqXCeMw8katQitnXDKWuKi1F/listings/coot-t-shirt.json  where  QmfHTiFpqLDAVj29Nf7LrfUFfz4envqArY4Gv7CvbyDcPt  is our  peerID .  And by using other naming protocols such as  Blockstack  we can cryptographically map a user's  peerID , which is a rather ugly looking series of numbers and letters, to a more human readable username such as  @UrbanArt . Thus one only needs to know the human readable username to download user content in a cryptographically secure manner.", 
            "title": "IPNS"
        }, 
        {
            "location": "/overview/#bitcoin", 
            "text": "The digital currency Bitcoin is used in OpenBazaar as the primary means of payment. The reason for this choice is two-fold. First, it aligns well with the goals of the project to be a decentralized, censorship-resistant eCommerce platform without a middle man. Bitcoin is also decentralized, censorship-resistant, and has no middlemen. It also has very low transaction fees compared to other forms of payment. Presently a bitcoin transaction can be made for about 10\u00a2 USD compared to about 30\u00a2  plus  2.9% of the total for PayPal. Credit cards similarly take a percentage of the transaction. And, of course, those methods of payment can be tracked and censored if need be.   We should supplement the previous statement on fees slightly. If a user wishes to convert bitcoins he earned from selling on OpenBazaar to fiat currency, he likely will incur some additional fees for the currency conversion. However, presently the company  Coinbase  allows vendors to convert up to $1 million USD for free and at a 1% fee for everything over $1 million. Which is to say, even when factoring in currency conversion, Bitcoin can still be far cheaper than the alternatives (and of course there are zero fees to sell on OpenBazaar).   The second reason Bitcoin is a good choice is it allows us to build the trustless escrow system we mentioned earlier. All other forms of payment require you to use the payment provider (such as PayPal) for arbitration if you have a dispute. With Bitcoin, we can not only create a free market for escrow/arbitration services, but we can do so in such a way as to remove the risk that the escrow agent will steal (or lose) the funds.", 
            "title": "Bitcoin"
        }, 
        {
            "location": "/overview/#multisig-scripts", 
            "text": "If you like to learn more about how Bitcoin works we'd suggest reading the  Bitcoin Developer Guide . However, we can provide a quick overview of how the escrow system works.   In Bitcoin, the coins are not technically sent to a bitcoin \"address\" or account. Instead, they are sent to a tiny computer program (or script). This script sets the terms upon which the coins are allowed to be transferred. A person seeking to spend bitcoins provides the inputs to the script function and the bitcoin software will execute it. If the script returns  True  (and all other transaction checks pass) then the bitcoins may be transferred to another script.   The specific script we use looks something like this:  OP_HASH160  Hash160(redeemScript)  OP_EQUAL  Technically this script means \"anyone who knows a certain password can spend these coins\", however Bitcoin underwent a soft-fork upgrade several years ago which gives this script a \"special\" meaning. In essence, when the interpreter sees this script it interprets it, not as a password script, but as something called \"pay to script hash\" or P2SH.  Coins sent to this script can be spent by providing a  redeem script  whose hash matches the hash in the output script and then by fulfilling the terms of the  redeem script .  In OpenBazaar we use a redeem script that looks like:  OP_2  buyer_pubkey   vendor_pubkey   moderator_pubkey  OP_3 OP_CHECKMULTISIG  This script says the funds may be transferred if signatures matching two of the three listed public keys are provided.  The scripting language is flexible enough that we could extend it with additional features in the future. For example, suppose we want to add a timeout to the escrow. That is, if the buyer doesn't release the fund or file a dispute within 60 days, the funds will then be transferred to the vendor. Essentially this can save the vendor some headaches trying to collect his payment.   This redeem script would look like:  OP_IF\n    OP_2  buyer_pubkey   vendor_pubkey   moderator_pubkey  OP_3 OP_CHECKMULTISIG\nOP_ELSE\n    60d  OP_CHECKSEQUENCEVERIFY OP_DROP\n     vendor_pubkey  OP_CHECKSIG\nOP_ENDIF", 
            "title": "Multisig scripts"
        }, 
        {
            "location": "/overview/#bitcoin-wallets", 
            "text": "The OpenBazaar protocol specification has nothing to say about which Bitcoin wallet should be used with the protocol. However, to improve the user experience, the reference implementation comes bundled with a built-in wallet. The default wallet implements something call Simplified Payment Verification (SPV) which provides strong cryptographic validation of incoming Bitcoin transactions while using very little of the computer's resources. The drawback to SPV mode is it leaks enough private data to allow potential attackers to figure out which transactions came from the wallet. Although that information by itself doesn't say who the  owner  of the wallet is (other investigative techniques might provide that information, however).   For this reason, there is a setting in the openbazaar-go config file that allows a user to use bitcoind (a full Bitcoin implementation) with openbazaar-go. Bitcoind is a very heavyweight software and is typically only used by power users, but it does a much better job than SPV at providing transactional privacy.", 
            "title": "Bitcoin Wallets"
        }, 
        {
            "location": "/overview/#altcoins", 
            "text": "There isn't anything Bitcoin-specific about Kademlia, IPFS, or Ricardian Contracts. In theory, the OpenBazaar protocol could work with any digital currency, not just Bitcoin. In practice, there are certain features a digital currency must have to be used with the OpenBazaar protocol that not every altcoin has. For example, an altcoin must support multisignature transactions else the escrow system will not work. The protocol also makes some assumptions about the existence of payment addresses and transaction inputs and outputs. These assumptions could probably be abstracted away in future versions of the protocol, but it stands to reason that altcoins that are a close derivative to Bitcoin would work better with the OpenBazaar protocol than coins that are a dramatic departure from it.", 
            "title": "Altcoins"
        }, 
        {
            "location": "/overview/#ricardian-contracts", 
            "text": "A traditional contract is a written or spoken agreement among two (or more) parties to exchange something of value. Every time we transact for anything we are entering into a legally binding contract, even if they are only verbal. When you purchase things on the internet, you are likewise entering into a legally binding contract. However, contracts are sometimes poorly written, ambiguous or difficult to interpret. They may be subject to  frog-boiling  where a strong party attempts to change the contract over time in his favor or even to one party denying they agreed on the contract. These issues can make it difficult for arbitrators to determine who is correct in a dispute.   A Ricardian Contract is a type of cryptographic contract that attempts to solve these problems. Ricardian contracts a both human readable and machine parsable and provides an irrefutable record of what both parties agree to. It's not clear whether a Ricardian Contract would be treated as a valid contract in court (it would likely vary by jurisdiction anyway) but it doesn't matter as the terms of the contract can be enforced programmatically by software.   In OpenBazaar the Ricardian Contract looks as follows:  syntax =  proto3 ;\n\nmessage RicardianContract {\n    repeated Listing vendorListings                    = 1;\n    Order buyerOrder                                   = 2;\n    OrderConfirmation vendorOrderConfirmation          = 3;\n    repeated OrderFulfillment vendorOrderFulfillment   = 4;\n    OrderCompletion buyerOrderCompletion               = 5;\n    Dispute dispute                                    = 6;\n    DisputeResolution disputeResolution                = 7;\n    Refund refund                                      = 8;\n    repeated Signature signatures                      = 9;\n}  Each section of the contract is signed by the appropriate party's identity key. For example, the vendor signs the  Listing  object while the buyer signs the  Order  object. As the order progresses through different states, new objects are appended to the contract along with their signatures. When a dispute is filed with a moderator, the contract is sent to the moderator, programmatically validated, and then marshaled to JSON for the moderator to read. The contract contains all the information a moderator needs to make a decision and doesn't provide any wiggle room for the buyer and vendor to try to manipulate the outcome.   The Ricardian Contract structure is very extensible and allows virtually an unlimited number of contract types to be created.", 
            "title": "Ricardian Contracts"
        }, 
        {
            "location": "/protocol/", 
            "text": "", 
            "title": "Protocol"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/glossary/", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/references/", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/examples/", 
            "text": "", 
            "title": "Examples"
        }
    ]
}